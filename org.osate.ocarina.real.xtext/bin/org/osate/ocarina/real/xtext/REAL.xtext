grammar org.osate.ocarina.real.xtext.REAL hidden(WS, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate real "http://www.osate.org/org/osate/ocarina/real/xtext/REAL"

Model:
	theorems+=Theorem*;
	
Theorem:
	'theorem' name=ID rangeDefinition=RangeDefinition (setDeclarations+=SetDeclaration)* (requiredDefinition=RequiredDefinition)?
	(verificationExpression=VerificationExpression | evaluationExpression=EvaluationExpression) 'end' (endName=ID)? PUNC_SEMI_COLON;

RangeDefinition:
	'foreach' element=ID 'in' set=SetExpression 'do';

SetDeclaration:
	set=ID (PUNC_OPEN_PARENTHESIS paramIdentifier=ID PUNC_CLOSE_PARENTHESIS)? AFFECTATION_OPERATOR PUNC_OPEN_BRACE elementBinding=ElementBinding '|' expr=SelectionExpression PUNC_CLOSE_BRACE PUNC_SEMI_COLON;

ElementBinding:
	element=ID 'in' set=SetExpression;
	
SelectionExpression:
	e1=TerminalSelectionExpression (op+=BooleanOperator e2+=TerminalSelectionExpression)*;

TerminalSelectionExpression:
		e=GenericExpression |
		r=SelectionRelation;

SelectionRelation:
	identifier=SelectionRelationIdentifier PUNC_OPEN_PARENTHESIS (arguments+=SelectionRelationParameter (PUNC_COMMA arguments+=SelectionRelationParameter)*)? PUNC_CLOSE_PARENTHESIS;

// TODO: Case sensitivity. REAL vs Xtext
// Turns literals into tokens
SelectionRelationIdentifier:
	'Is_Subcomponent_Of' | 
	'Is_Bound_To' | 
	'Is_Provided_Class' |
	'Is_Connected_To' | 
	'Compare_Property_Value' | 
	'Is_Called_By' | 
	'Is_Calling' |
	'Is_Accessed_By' | 
	'Is_Connecting_To' |
	'Is_Accessing_To';

SelectionRelationParameter:
	l=Literal | identifier=ID;

RequiredDefinition:
	'requires' PUNC_OPEN_PARENTHESIS theorems+=ID (PUNC_COMMA theorems+=ID)* PUNC_CLOSE_PARENTHESIS PUNC_SEMI_COLON;

// Should have verification sub expression but that causes problems with parsing currently
VerificationExpression:
	'check' PUNC_OPEN_PARENTHESIS e1=GenericExpression PUNC_CLOSE_PARENTHESIS PUNC_SEMI_COLON;

EvaluationExpression:
	'return' PUNC_OPEN_PARENTHESIS f=AggregationFunctionIdentifier PUNC_OPEN_PARENTHESIS e=GenericExpression PUNC_CLOSE_PARENTHESIS PUNC_CLOSE_PARENTHESIS PUNC_SEMI_COLON;

GenericExpression:
	e1=TerminalGenericExpression (op+=GenericOperator e2+=TerminalGenericExpression)*;
	
TerminalGenericExpression:
	literal=Literal |
	fc=VerificationFunctionCall | 
	te=TernaryExpression |
	PUNC_OPEN_PARENTHESIS GenericExpression PUNC_CLOSE_PARENTHESIS;

SetExpression:
	e1=TerminalSetExpression (op+=SetOperator e2+=TerminalSetExpression)*;
	
TerminalSetExpression :
	ID;

TernaryExpression:
	'if' conditional=GenericExpression 'then' trueValue=GenericExpression 'else' falseValue=GenericExpression;

VerificationFunctionCall:
	f=VerificationFunctionIdentifier PUNC_OPEN_PARENTHESIS arguments+=VerificationFunctionParameter (PUNC_COMMA arguments+=VerificationFunctionParameter)* PUNC_CLOSE_PARENTHESIS;

VerificationFunctionParameter:
	l=Literal |
	identifier=ID |
	vfi=VerificationFunctionCall;

AggregationFunctionIdentifier:
	'MSum' |
	'MMax';

VerificationFunctionIdentifier:
	'Cardinal' |
	'Sum' |
	'Max' |
	'Min' |
	'Product' |
	'GCD' |
	'LCM' |
	'Get_Property_Value' |
	'Property' |
	'Property_Exists' |
	'All_Equals' |
	'Exists' |
	'System' |
	'First' |
	'Last' |
	'Head' |
	'Queue' |
	'List' |
	'Size' |
	'Float';

GenericOperator:
	ComparisonOperator | 
	BooleanOperator | 
	ArithmeticOperator;

// TODO: String literal syntax...
// TODO: Numeric literal snytax
Literal:
	b=BOOLEAN | s=STRING | n=NUMERIC;

BOOLEAN:
	value=('true' | 'false');

SetOperator:
	PLUS |
	STAR |
	SLASH;

ArithmeticOperator:
	PLUS | 
	MINUS | 
	STAR | 
	SLASH | 
	POWER;

// TODO: Check REAL for meaning of [not]
BooleanOperator:
	AND |
	NOT |
	OR;

ComparisonOperator:
	LESS |
	LESS_EQUAL |
	EQUAL |
	GREATER_EQUAL |
	GREATER |
	NOT_EQUAL;
	
terminal PLUS : '+';
terminal POWER : '**';
terminal STAR : '*';
terminal SLASH : '/';
terminal MINUS : '-';
terminal AND : 'and';
terminal NOT : 'not';
terminal OR : 'or';
terminal NOT_EQUAL : '<>';
terminal LESS_EQUAL : '<=';
terminal GREATER_EQUAL : '>=';
terminal GREATER : '>';
terminal LESS : '<';
terminal EQUAL : '=';

terminal AFFECTATION_OPERATOR : ':=';
terminal PUNC_OPEN_BRACE : '{';
terminal PUNC_CLOSE_BRACE : '}';
terminal PUNC_SEMI_COLON : ';';
terminal PUNC_OPEN_PARENTHESIS : '(';
terminal PUNC_CLOSE_PARENTHESIS : ')';
terminal PUNC_COMMA : ',';

terminal ID : 
  ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')* ;

// Note: Rule may broader than what REAL supports. Not included in BNF
terminal STRING	: 
  '"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
  "'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )* "'"; 
terminal SL_COMMENT : '--' !('\n'|'\r')* ('\r'? '\n')? ;
terminal WS	 : (' '|'\t'|'\r'|'\n')+ ;

// Not a strict rule. Should be enough to cover all types of numeric values supported by REAL
terminal NUMERIC:
	('0'..'9'|'.'|'+'|'-'|'a'..'z'|'A'..'Z')+;
